// Code generated by goa v3.13.2, DO NOT EDIT.
//
// librarian HTTP client CLI support package
//
// Command:
// $ goa gen github.com/dgdraganov/super-librarian/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"
	"unicode/utf8"

	librarian "github.com/dgdraganov/super-librarian/gen/librarian"
	goa "goa.design/goa/v3/pkg"
)

// BuildGetBookPayload builds the payload for the librarian get-book endpoint
// from CLI flags.
func BuildGetBookPayload(librarianGetBookID string) (*librarian.GetBookPayload, error) {
	var err error
	var id int
	{
		var v int64
		v, err = strconv.ParseInt(librarianGetBookID, 10, strconv.IntSize)
		id = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for id, must be INT")
		}
		if id < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("id", id, 1, true))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &librarian.GetBookPayload{}
	v.ID = id

	return v, nil
}

// BuildGetBooksPayload builds the payload for the librarian get-books endpoint
// from CLI flags.
func BuildGetBooksPayload(librarianGetBooksSkip string, librarianGetBooksTake string) (*librarian.GetBooksPayload, error) {
	var err error
	var skip int
	{
		var v int64
		v, err = strconv.ParseInt(librarianGetBooksSkip, 10, strconv.IntSize)
		skip = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for skip, must be INT")
		}
		if skip < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("skip", skip, 0, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var take int
	{
		var v int64
		v, err = strconv.ParseInt(librarianGetBooksTake, 10, strconv.IntSize)
		take = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for take, must be INT")
		}
		if take < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("take", take, 1, true))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &librarian.GetBooksPayload{}
	v.Skip = skip
	v.Take = take

	return v, nil
}

// BuildCreateBookPayload builds the payload for the librarian create-book
// endpoint from CLI flags.
func BuildCreateBookPayload(librarianCreateBookBody string) (*librarian.CreateBookPayload, error) {
	var err error
	var body CreateBookRequestBody
	{
		err = json.Unmarshal([]byte(librarianCreateBookBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"author\": \"3ew\",\n      \"book_cover\": \"a3\",\n      \"published_at\": \"2006-04-23\",\n      \"title\": \"u5h\"\n   }'")
		}
		if utf8.RuneCountInString(body.Title) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 1, true))
		}
		if utf8.RuneCountInString(body.Title) > 255 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 255, false))
		}
		if utf8.RuneCountInString(body.Author) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.author", body.Author, utf8.RuneCountInString(body.Author), 3, true))
		}
		if utf8.RuneCountInString(body.Author) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.author", body.Author, utf8.RuneCountInString(body.Author), 100, false))
		}
		if utf8.RuneCountInString(body.BookCover) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.book_cover", body.BookCover, utf8.RuneCountInString(body.BookCover), 1, true))
		}
		if utf8.RuneCountInString(body.BookCover) > 2048 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.book_cover", body.BookCover, utf8.RuneCountInString(body.BookCover), 2048, false))
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.published_at", body.PublishedAt, goa.FormatDate))
		if err != nil {
			return nil, err
		}
	}
	v := &librarian.CreateBookPayload{
		Title:       body.Title,
		Author:      body.Author,
		BookCover:   body.BookCover,
		PublishedAt: body.PublishedAt,
	}

	return v, nil
}

// BuildUpdateBookPayload builds the payload for the librarian update-book
// endpoint from CLI flags.
func BuildUpdateBookPayload(librarianUpdateBookBody string) (*librarian.UpdateBookPayload, error) {
	var err error
	var body UpdateBookRequestBody
	{
		err = json.Unmarshal([]byte(librarianUpdateBookBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"author\": \"iae\",\n      \"book_cover\": \"yd\",\n      \"id\": 3737986959803916148,\n      \"published_at\": \"1984-06-22\",\n      \"title\": \"7p\"\n   }'")
		}
		if body.ID != nil {
			if *body.ID < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.id", *body.ID, 1, true))
			}
		}
		if utf8.RuneCountInString(body.Title) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 1, true))
		}
		if utf8.RuneCountInString(body.Title) > 255 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 255, false))
		}
		if utf8.RuneCountInString(body.Author) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.author", body.Author, utf8.RuneCountInString(body.Author), 3, true))
		}
		if utf8.RuneCountInString(body.Author) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.author", body.Author, utf8.RuneCountInString(body.Author), 100, false))
		}
		if utf8.RuneCountInString(body.BookCover) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.book_cover", body.BookCover, utf8.RuneCountInString(body.BookCover), 1, true))
		}
		if utf8.RuneCountInString(body.BookCover) > 2048 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.book_cover", body.BookCover, utf8.RuneCountInString(body.BookCover), 2048, false))
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.published_at", body.PublishedAt, goa.FormatDate))
		if err != nil {
			return nil, err
		}
	}
	v := &librarian.UpdateBookPayload{
		ID:          body.ID,
		Title:       body.Title,
		Author:      body.Author,
		BookCover:   body.BookCover,
		PublishedAt: body.PublishedAt,
	}

	return v, nil
}

// BuildDeleteBookPayload builds the payload for the librarian delete-book
// endpoint from CLI flags.
func BuildDeleteBookPayload(librarianDeleteBookID string) (*librarian.DeleteBookPayload, error) {
	var err error
	var id int
	{
		var v int64
		v, err = strconv.ParseInt(librarianDeleteBookID, 10, strconv.IntSize)
		id = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for id, must be INT")
		}
	}
	v := &librarian.DeleteBookPayload{}
	v.ID = id

	return v, nil
}
